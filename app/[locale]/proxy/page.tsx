import { setRequestLocale } from 'next-intl/server';
import { ProxyPageContent } from '@/components/pages/proxy-content';
import { Metadata } from 'next';
import { normalizeUrl } from '@/lib/validation/url';

type Props = {
  params: Promise<{ locale: string }>;
  searchParams: Promise<{ url?: string; sidebar?: string }>;
};

// Default metadata - images are handled by opengraph-image.tsx and twitter-image.tsx
const DEFAULT_METADATA: Metadata = {
  title: 'Proxy | Smry',
  description: 'Read articles with Smry',
  // Don't index proxy pages in search engines (avoid duplicate content)
  // But allow Twitter/Facebook crawlers to fetch OG metadata
  robots: {
    index: false,
    follow: true,
  },
  openGraph: {
    type: 'website',
    title: 'Proxy | Smry',
    description: 'Read articles with Smry',
    siteName: 'smry.ai',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'Proxy | Smry',
    description: 'Read articles with Smry',
  },
};

// Generate dynamic metadata for OG tags
// Note: OG images are generated by opengraph-image.tsx and twitter-image.tsx
// to avoid robots.txt blocking issues with external image URLs
export async function generateMetadata({ searchParams }: Props): Promise<Metadata> {
  const { url: rawUrl } = await searchParams;

  if (!rawUrl) {
    return DEFAULT_METADATA;
  }

  // Normalize URL
  let normalizedUrl: string;
  try {
    normalizedUrl = normalizeUrl(rawUrl);
  } catch {
    return DEFAULT_METADATA;
  }

  // Build the canonical URL (the clean shareable format)
  const canonicalUrl = `${process.env.NEXT_PUBLIC_URL || 'https://smry.ai'}/${normalizedUrl}`;

  // Get the API URL - only fetch if we have a proper API URL configured
  const apiBaseUrl = process.env.NEXT_PUBLIC_URL;

  // If no API URL is configured, return basic metadata with URL info
  if (!apiBaseUrl) {
    const hostname = new URL(normalizedUrl).hostname.replace('www.', '');
    return {
      title: `Article from ${hostname} | Smry`,
      description: `Read this article from ${hostname} with Smry`,
      robots: { index: false, follow: true }, // Don't index in search engines
      openGraph: {
        type: 'article',
        title: `Article from ${hostname}`,
        description: `Read this article from ${hostname} with Smry`,
        siteName: 'smry.ai',
        url: canonicalUrl,
      },
      twitter: {
        card: 'summary_large_image',
        title: `Article from ${hostname}`,
        description: `Read this article from ${hostname} with Smry`,
      },
    };
  }

  try {
    // Fetch article data for metadata with timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

    const response = await fetch(
      `${apiBaseUrl}/api/article/auto?url=${encodeURIComponent(normalizedUrl)}`,
      {
        signal: controller.signal,
        next: { revalidate: 3600 }, // Cache for 1 hour
      }
    );

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error('Failed to fetch article');
    }

    const data = await response.json();
    const article = data.article;

    if (!article) {
      return DEFAULT_METADATA;
    }

    const title = article.title ? `${article.title} | Smry` : 'Proxy | Smry';
    const description = article.textContent
      ? article.textContent.slice(0, 200).trim() + '...'
      : 'Read articles with Smry';

    // Return metadata WITHOUT explicit image URLs
    // Images are generated by opengraph-image.tsx and twitter-image.tsx
    // This avoids robots.txt blocking issues with external CDN images
    return {
      title,
      description,
      robots: { index: false, follow: true }, // Don't index in search engines
      openGraph: {
        type: 'article',
        title: article.title || 'Smry',
        description,
        siteName: 'smry.ai',
        url: canonicalUrl,
        // Images handled by opengraph-image.tsx
      },
      twitter: {
        card: 'summary_large_image',
        title: article.title || 'Smry',
        description,
      },
    };
  } catch {
    // If fetch fails, return basic metadata without logging error
    // This is expected in development when API URL is not set
    const hostname = new URL(normalizedUrl).hostname.replace('www.', '');
    return {
      title: `Article from ${hostname} | Smry`,
      description: `Read this article from ${hostname} with Smry`,
      robots: { index: false, follow: true }, // Don't index in search engines
      openGraph: {
        type: 'article',
        title: `Article from ${hostname} | Smry`,
        description: `Read this article from ${hostname} with Smry`,
        siteName: 'smry.ai',
        url: canonicalUrl,
      },
      twitter: {
        card: 'summary_large_image',
        title: `Article from ${hostname} | Smry`,
        description: `Read this article from ${hostname} with Smry`,
      },
    };
  }
}

export default async function ProxyPage({ params, searchParams }: Props) {
  const { locale } = await params;
  const { sidebar } = await searchParams;
  setRequestLocale(locale);

  // Parse sidebar param on server to prevent layout shift
  const initialSidebarOpen = sidebar === 'true';

  return <ProxyPageContent initialSidebarOpen={initialSidebarOpen} />;
}
