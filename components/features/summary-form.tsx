"use client";

import React, { useState, useMemo, useEffect, useRef } from "react";
import { useCompletion } from "@ai-sdk/react";
import { LANGUAGES, Source, ArticleResponse } from "@/types/api";
import { Button } from "../ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
} from "@/components/ui/select";
import { Skeleton } from "@/components/ui/skeleton";
import { UseQueryResult } from "@tanstack/react-query";
import useLocalStorage from "@/lib/hooks/use-local-storage";
import { Response } from "../ai/response";

type ArticleResults = Record<Source, UseQueryResult<ArticleResponse, Error>>;

const SOURCE_LABELS: Record<Source, string> = {
  "smry-fast": "smry (fast)",
  "smry-slow": "smry (slow)",
  wayback: "Wayback",
  "jina.ai": "Jina.ai",
};

const SUMMARY_SOURCES: Source[] = ["smry-fast", "smry-slow", "wayback", "jina.ai"];

interface SummaryFormProps {
  urlProp: string;
  ipProp: string;
  articleResults: ArticleResults;
}

export default function SummaryForm({ urlProp, ipProp, articleResults }: SummaryFormProps) {
  // Minimum character threshold for summary eligibility
  const MIN_CHARS_FOR_SUMMARY = 400;

  // Find the source with the longest content from already-loaded articles
  // Only consider sources with at least MIN_CHARS_FOR_SUMMARY characters
  const longestAvailableSource = useMemo(() => {
    const sources: { source: Source; length: number }[] = SUMMARY_SOURCES.map((source) => ({
      source,
      length: articleResults[source]?.data?.article?.textContent?.length || 0,
    })).filter((s) => s.length >= MIN_CHARS_FOR_SUMMARY);

    // Sort by length and return the longest
    sources.sort((a, b) => b.length - a.length);
    return sources[0]?.source || SUMMARY_SOURCES[0]; // Fallback to first source if none meet threshold
  }, [articleResults]);

  // Allow manual source selection, but default to longest available
  const [manualSource, setManualSource] = useState<Source | null>(null);
  const selectedSource = manualSource || longestAvailableSource;

  // Get the currently selected article data
  const selectedArticle = articleResults[selectedSource]?.data;

  // Persist language preference
  const [preferredLanguage, setPreferredLanguage] = useLocalStorage<string>("summary-language", "en");

  // Use AI SDK's useCompletion hook for streaming
  const { completion, complete, isLoading, error } = useCompletion({
    api: '/api/summary',
    streamProtocol: 'text', // Use plain text streaming
    body: {
      title: selectedArticle?.article?.title,
      url: urlProp,
      ip: ipProp,
      language: preferredLanguage,
    },
  });

  const handleRegenerate = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedArticle?.article?.textContent) return;
    
    await complete(selectedArticle.article.textContent);
  };

  const handleLanguageChange = (newLanguage: string) => {
    setPreferredLanguage(newLanguage);
    // Don't auto-regenerate - user must click Regenerate button
  };

  // Check if ANY article has loaded (not just if they're currently loading)
  const hasArticleData = Object.values(articleResults).some((result) => result.data?.article?.textContent);
  const allArticlesLoading = Object.values(articleResults).every((result) => result.isLoading);
  const shouldDisableSource = allArticlesLoading || !hasArticleData;

  // Get content lengths for display
  const contentLengths = SUMMARY_SOURCES.reduce<Record<Source, number>>((acc, source) => {
    acc[source] = articleResults[source].data?.article?.textContent?.length || 0;
    return acc;
  }, {
    "smry-fast": 0,
    "smry-slow": 0,
    wayback: 0,
    "jina.ai": 0,
  });

  // Track if we've auto-generated
  const hasAutoGeneratedRef = useRef(false);

  // Auto-generate on mount when valid content is available
  useEffect(() => {
    if (
      !hasAutoGeneratedRef.current &&
      !completion &&
      !isLoading &&
      selectedArticle?.article?.textContent &&
      contentLengths[selectedSource] >= MIN_CHARS_FOR_SUMMARY
    ) {
      hasAutoGeneratedRef.current = true;
      complete(selectedArticle.article.textContent);
    }
  }, [selectedArticle, completion, isLoading, complete, selectedSource, contentLengths]);

  // Helper to determine if a source should be disabled and why
  const getSourceStatus = (source: Source) => {
    const result = articleResults[source];
    const length = contentLengths[source];

    if (result.isLoading) {
      return { disabled: true, label: "Loading..." };
    }
    if (result.isError) {
      return { disabled: true, label: "Failed" };
    }
    if (length > 0 && length < MIN_CHARS_FOR_SUMMARY) {
      return { disabled: true, label: "Too short" };
    }
    if (length === 0 && !result.isLoading) {
      return { disabled: true, label: "No content" };
    }
    return { disabled: false, label: null };
  };

  const errorContent = useMemo(() => {
    if (!error) return null;
    const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred";
    const isLengthError = errorMessage.toLowerCase().includes("content must be at least");
    
    if (isLengthError) {
      return {
        title: "Content Too Short",
        message: "This article doesn't have enough content to generate a high-quality summary. Please try a different source tab above, or view the original article.",
        bgClass: "bg-amber-500/10",
        textClass: "text-amber-600 dark:text-amber-400",
        titleClass: "text-amber-700 dark:text-amber-300"
      };
    }

    return {
      title: "Error",
      message: errorMessage,
      bgClass: "bg-red-500/10",
      textClass: "text-red-600 dark:text-red-400",
      titleClass: "text-red-700 dark:text-red-300"
    };
  }, [error]);

  return (
    <div className="flex h-full flex-col overflow-hidden">
      <div className="min-h-0 flex-1 overflow-y-auto">
        <div className="space-y-4 p-6">
        {error && errorContent && (
          <div className={`rounded-[14px] p-0.5 ${errorContent.bgClass}`}>
            <div className="rounded-xl bg-white/50 p-4 dark:bg-zinc-950/50">
              <h3 className={`mb-1 text-xs font-medium uppercase tracking-wide ${errorContent.titleClass}`}>
                {errorContent.title}
              </h3>
              <p className={`text-sm ${errorContent.textClass}`}>
                {errorContent.message}
              </p>
            </div>
          </div>
        )}

        {(completion || isLoading) && (
          <div className="rounded-[14px] bg-zinc-100 p-0.5 dark:bg-zinc-800">
            <div className="rounded-xl bg-white p-5 dark:bg-zinc-950">
              <div className="mb-4 flex items-center gap-2 border-b border-zinc-100 pb-4 dark:border-zinc-900">
                <div className="flex size-6 items-center justify-center rounded-full bg-purple-100 text-purple-600 dark:bg-purple-900/30 dark:text-purple-400">
                  <svg className="size-3.5" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z" />
                  </svg>
                </div>
                <h3 className="text-sm font-medium text-zinc-900 dark:text-zinc-100">
                  Executive Summary
                  {isLoading && (
                    <span className="ml-2 text-xs font-normal text-zinc-400">
                      {completion ? "Streaming..." : "Generating..."}
                    </span>
                  )}
                </h3>
              </div>
              <div className="text-zinc-600 dark:text-zinc-300">
                {completion ? (
                  <>
                    <Response>
                      {completion}
                    </Response>
                    {isLoading && (
                      <div className="mt-2">
                        <span className="inline-block h-4 w-0.5 animate-pulse bg-purple-500"></span>
                      </div>
                    )}
                  </>
                ) : (
                  <div className="space-y-3">
                    <Skeleton className="h-4 w-full" />
                    <Skeleton className="h-4 w-[90%]" />
                    <Skeleton className="h-4 w-4/5" />
                  </div>
                )}
              </div>
            </div>
          </div>
        )}
      </div>
      </div>

      <div className="z-10 border-t border-zinc-200/50 bg-zinc-50 px-6 pb-6 pt-4 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.02)] dark:border-zinc-800/50 dark:bg-zinc-900">
        <form onSubmit={handleRegenerate} className="space-y-2">
          <div className="flex items-center gap-2">
            <div className="min-w-0 flex-1">
              <Select
                value={selectedSource}
                onValueChange={(value) => setManualSource(value as Source)}
                disabled={shouldDisableSource || isLoading}
              >
                <SelectTrigger className="h-9 w-full border-zinc-200 bg-white text-sm font-medium focus:ring-zinc-100 dark:border-zinc-800 dark:bg-zinc-950 dark:focus:ring-zinc-800">
                  <span className="truncate text-left">
                    {SOURCE_LABELS[selectedSource]}
                    {longestAvailableSource === selectedSource && (
                      <span className="ml-2 text-xs font-normal text-purple-500">Best</span>
                    )}
                  </span>
                </SelectTrigger>
                <SelectContent>
                  {SUMMARY_SOURCES.map((source) => {
                    const status = getSourceStatus(source);
                    const length = contentLengths[source];
                    return (
                      <SelectItem key={source} value={source} disabled={status.disabled}>
                        <span className="flex items-center gap-2">
                          <span>{SOURCE_LABELS[source]}</span>
                          {length > 0 && <span className="text-zinc-400">• {length.toLocaleString()} chars</span>}
                          {status.label && <span className="text-zinc-400">• {status.label}</span>}
                          {longestAvailableSource === source && !status.disabled && <span className="text-purple-500">• Best</span>}
                        </span>
                      </SelectItem>
                    );
                  })}
                </SelectContent>
              </Select>
            </div>

            <div className="w-[110px] shrink-0">
              <Select
                value={preferredLanguage}
                onValueChange={handleLanguageChange}
                disabled={isLoading}
              >
                <SelectTrigger className="h-9 w-full border-zinc-200 bg-white text-sm font-medium focus:ring-zinc-100 dark:border-zinc-800 dark:bg-zinc-950 dark:focus:ring-zinc-800">
                   <span className="truncate text-left">
                    {LANGUAGES.find(l => l.code === preferredLanguage)?.name || "Language"}
                   </span>
                </SelectTrigger>
                <SelectContent>
                  {LANGUAGES.map((lang) => (
                    <SelectItem key={lang.code} value={lang.code}>
                      {lang.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <Button 
              type="submit" 
              variant={completion ? "outline" : "default"}
              disabled={isLoading || shouldDisableSource || !selectedArticle?.article?.textContent}
              className="h-9 shrink-0 px-4 text-sm font-medium transition-all active:scale-95"
            >
              {isLoading ? "Generating..." : completion ? "Update" : "Generate"}
            </Button>
          </div>
          
          {!manualSource && hasArticleData && (
            <p className="truncate px-2 text-center text-[10px] text-zinc-400">
              Auto-selected best source ({contentLengths[selectedSource].toLocaleString()} chars)
            </p>
          )}
        </form>
      </div>
    </div>
  );
}
